# Generated by Django 6.0.2 on 2026-02-10 16:49

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Event',
            fields=[
                ('event_id', models.UUIDField(default=uuid.uuid4, editable=False, help_text='Unique event identifier. Enforces idempotency.', primary_key=True, serialize=False)),
                ('event_type', models.CharField(help_text='Namespaced event type from registry. Format: engine.domain.action (e.g. inventory.stock.moved).', max_length=255)),
                ('event_version', models.PositiveSmallIntegerField(help_text="Schema version of this event type's payload.")),
                ('business_id', models.UUIDField(help_text='Business tenant boundary. Always required.')),
                ('branch_id', models.UUIDField(blank=True, help_text='Branch scope. Nullable for business-wide events.', null=True)),
                ('source_engine', models.CharField(help_text='Engine that emitted this event. Each engine writes only its own events.', max_length=100)),
                ('actor_type', models.CharField(choices=[('HUMAN', 'Human'), ('SYSTEM', 'System'), ('DEVICE', 'Device'), ('AI', 'AI')], help_text='Type of actor: HUMAN, SYSTEM, DEVICE, or AI.', max_length=20)),
                ('actor_id', models.CharField(help_text='Unique identifier of the actor (user ID, system ID, device ID, AI agent ID).', max_length=255)),
                ('correlation_id', models.UUIDField(help_text='Groups events belonging to the same story/journey (e.g. a full checkout flow). Required — every event belongs to a story.')),
                ('causation_id', models.UUIDField(blank=True, help_text='The event_id that directly caused this event. Nullable — the first event in a causal chain has no cause.', null=True)),
                ('payload', models.JSONField(help_text='Versioned event payload. Structure governed by event_type + event_version. Part of the event envelope.')),
                ('reference', models.JSONField(blank=True, default=dict, help_text='Optional external reference context (e.g. receipt ID, PO number).')),
                ('created_at', models.DateTimeField(help_text='When the event was created at source.')),
                ('received_at', models.DateTimeField(auto_now_add=True, help_text='When the Event Store received and persisted this event.')),
                ('status', models.CharField(choices=[('FINAL', 'Final'), ('PROVISIONAL', 'Provisional'), ('REVIEW_REQUIRED', 'Review Required')], default='FINAL', help_text='FINAL — trusted and confirmed. PROVISIONAL — offline/pending sync. REVIEW_REQUIRED — needs human review.', max_length=20)),
                ('correction_of', models.UUIDField(blank=True, help_text='References event_id of the event this corrects. Null if not a correction.', null=True)),
                ('previous_event_hash', models.CharField(help_text='SHA-256 hash of the immediately preceding event. Empty string for the very first event in the chain.', max_length=64)),
                ('event_hash', models.CharField(help_text="SHA-256 hash of this event's content + previous_event_hash. Ensures tamper-evident, audit-proof chain integrity.", max_length=64)),
            ],
            options={
                'db_table': 'bos_event_store',
                'ordering': ['received_at'],
                'indexes': [models.Index(fields=['business_id', 'received_at'], name='idx_evt_business_time'), models.Index(fields=['event_type'], name='idx_evt_type'), models.Index(fields=['source_engine'], name='idx_evt_source_engine'), models.Index(fields=['status'], name='idx_evt_status'), models.Index(fields=['correction_of'], name='idx_evt_correction_of'), models.Index(fields=['correlation_id'], name='idx_evt_correlation'), models.Index(fields=['causation_id'], name='idx_evt_causation')],
            },
        ),
    ]
